### Информация о курсе

#### Что изучается

В рамках данного курса необходимо реализовать собственные коллекции, которые будут являться несколько упрощенными
аналогами базовых коллекций из JDK.

#### Какова цель

Данный курс ставит следующие цели:
* концептуальное изучение базовых коллекций;
* понимание преимуществ инкапсуляции реализации за интерфейсом;
* понимание причин существования нескольких альтернативных реализаций одного интерфейса;
* знакомство и практика TDD (Test-Driven Development).

---

### Map

Создать интерфейс `Map`, содержащий методы:

* `int size()`  
  Количество элементов в коллекции.

* `boolean isEmpty()`  
  Проверка коллекции на пустоту (отсутствие элементов)

* `boolean containsKey(Object key)`  
  Проверка коллекции на наличие ключа `key` в рамках какой-либо из хранимых пар `<key, value>`.

* `boolean containsValue(Object value)`  
  Проверка коллекции на наличие значения `value` в рамках какой-либо из хранимых пар `<key, value>`.

* `Object get(Object key)`  
  Возвращение значения из пары `<key, value>`, в рамках которой ключ равен переданному `key`.  
  Если значение не было найдено, то возвращается `null`.  
  Хранимое в рамках коллекции значение также может иметь значение `null`,
  поэтому получение `null` не может быть использовано как признак отсутствия элемента в коллекции.  
  Допустимость использования `null` в качестве ключа коллекции зависит от конкретной реализации.

* `Object put(Object key, Object value)`  
  Вставка пары `<key, value>` в коллекцию.  
  Если в коллекции уже присутствует пара `<key, value>`, которая ключ равный переданному `key`, то в рамках данной пары произойдет замена `value`.  
  Хранимое в рамках коллекции `value` также может иметь значение `null`.  
  Допустимость использования `null` в качестве ключа коллекции зависит от конкретной реализации.

* `Object remove(Object key)`  
  Удаление из коллекции пары `<key, value>`, в рамках которой ключ равен `key`.  
  Возвращается значение `value` из удаленной пары `<key, value>`.  
  Если соответствующая пара не была найдена, то возвращается `null`.  
  Хранимое в рамках коллекции значение также может иметь значение `null`,
  поэтому получение `null` не может быть использовано как признак отсутствия пары `<key, value>`, в рамках которой `key` равен переданному.

* `void clear()`  
  Удаление всех пар `<key, value>` из коллекции.

* `Collection values()`  
  Получение новой коллекции, состоящей из всех значений, которые хранятся в рамках пар `<key, value>` данной коллекции.

* `Collection keySet()`  
  Получение новой коллекции, состоящей из всех ключей, которые хранятся в рамках пар `<key, value>` данной коллекции.

* `Collection entrySet()`  
  Получение новой коллекции, состоящей из пар `<key, value>`, которые хранятся в рамках данной коллекции.

_Примечание: в текущем описании `keySet` и `entrySet` возвращают интерфейс `Collection`, а не `Set`, т.к. интерфейс `Set` в рамках ряда данных заданий не реализовывался._

---

### HashMap

Создать класс `HashMap`, который будет реализовывать наш интерфейс `Map`, инкапсулируя в себе следующие особенности реализации:

* выделяется массив (`buckets`), элементами которого являются `LinkedList` (при работе с ним достаточно ограничиться интерфейсом `Deque`):
  * элементы массива принято называть корзинами (`entry`);
  * с точки зрения оптимизаций размер массива удобно делать степенью числа 2 (см. далее алгоритм рассчета номера корзины);
* вставка пары ключ значение (`put(key, value)`) реализована следующим образом:
  1. рассчитывается номер корзины: `int bucketNumder = key.hashCode() % buckets.length()`;
  2. происходит получение списка: `LinkedList list = buckets[bucketNumber]`;
  3. происходит обход `LinkedList` в поисках пары `<key, value>`, у которой ключ равен `key` из добавляемой пары:
    1. если пара найдена, то в рамках нее происходит замена `value`;
    2. если пара не найдена, то происходит вставка пары в конец списка: `LinkedList.addLast(new Entry(key, value))`;
* получение значения по ключу (`Object get(key)`) реализовано следующим образом:
  1. рассчитывается номер корзины: `int bucketNumder = key.hashCode() % buckets.length()`;
  2. происходит получение списка: `LinkedList list = buckets[bucketNumber]`;
  3. происходит обход `LinkedList` в поисках пары `<key, value>`, у которой ключ равен `key` из добавляемой пары:
    1. если пара найдена, то происходит возвращение из неё `value` (который мог быть `null`);
    2. если пара не найдена, то происходит возвращение `null`.

---

### TreeMap

Создать класс `TreeMap`, который будет реализовывать наш интерфейс `Map`, инкапсулируя в себе [двоичное дерево](https://ru.wikipedia.org/wiki/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0).

После завершения реализации двоичного дерева необходимо его доработать до [красно-черного дерева](https://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B0%D1%81%D0%BD%D0%BE-%D1%87%D1%91%D1%80%D0%BD%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE).